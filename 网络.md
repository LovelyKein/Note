# 客户端&服务器

在大部分情况下，通信总是由一方发出一个消息开始，而另一方回复一个消息结束
发出消息的一方称之为**客户端**`Client`，发出消息的过程称之为请求`Request`
回复消息的一方称之为**服务器**`Server`，回复消息的过程称之为响应`Response`

![image-20250614153552168](./assets/image-20250614153552168.png)

> [!NOTE]
>
> - **不管是客户端，还是服务器，它们都是一个应用程序，而不是一台计算机**
>   **客户端和服务器可以分布在不同的计算机上，也可以在同一台计算机上**
>   例如`liveserver`插件，就是一个服务务器，它运行在本地的计算机上
> - 大部分后端开发的就是服务器程序，前端的`NodeJs`技术也能开发服务器程序
> - 客户端和服务器的这种交互模式称之为「经典C/S结构」
>   在这种结构中，如果客户端是浏览器,则我们称之为「B/S结构」
> - 服务器程序往往是为互联网产品提供服务，因此又称之为`web`服务器
> - **一次完整的交互，总是从请求开始，响应结束**



# 地址`url`

在互联网中，我们可以通过一个叫`url`地址的东西找到我们想要的资源
`url`全称`uniform resource locator`，**统一资源定位符**
它是一个字符串，用于表达互联网中某个资源的位置

![image-20250614162350029](./assets/image-20250614162350029.png)



## 协议`protocol`

## 主机`Host`

它表示客户端希望在哪台计算机上寻找资源，有两种写法：`IP`地址和域名

### `IP`地址

记住特殊`IP`地址，`127.0.0.1`它表示本机`IP`地址

### 域名

域名类似`IP`地址的别名，把不容易记忆的数字要为容易记忆的单词
当使用成名访问时，会自动转换为`IP`地址
特殊域名`localhost`，它表示的`IP`地址是`127.0.0.1`

## 端口`Port`

它表示客户端希望在哪个应用程序中寻找资源
每个服务器程序，都会监听一个或多个端口，只有找到对应的端口，才能找到这个服务器程序
端口号是可选的，若不填写，则：

- 如果使用的是`http`协议，默认端口号为`80`
- 如果使用的是`https`协议，默认端口号为`443`

## 路径`Path`

服务器上往往有许许多多的资源，每个资源都有自己的访问路径
路径是可选的，若不写，则为`/`

## 参数`Query/Param`

某些资源可以根据需要呈现不同的内容，比如一篇新闻列表的页面，可以指定它呈现第几页的新闻
而「第几页」就属于一些额外信息，这些额外信息可以通过参数传递

```js
// 访问一个新闻列表的页面，同时希望它展示第5页，每页展示10条新闻，可得到下面的 url地址：
const url = 'http://duyiedu.com/news?page=1&limit=10'
```

## `hash`

在网络通信中，`hash`没有什么用，它往往作为浏览器的锚链接出现



# 网络协议`http`

通过url地址，能够在茫茫互联网中准确的找到自己想要的服务
但光找到服务还是不够，双方需要「用同一种语言」来对话，否则都听不懂对方在说什么
这个「语言」就是协议，而互联网中最常见的协议就是`http`协议
**`https`是在在`http`协议基础上发展起来的，它增加了安全性，其他和`http`协议完全一致**
http是基于「请求-响应」的方式完成通信的，每一次通信都是由客户端向服务器发出请求，传递一些消息过去，然后经过服务器程序处理后，响应给客户端一些消息
http协议规定：

- 每次「请求-响应」都是独立的，相互之间互不干扰，这种模式的协议我们称之为**无状态协议**
- **每次「请求-响应」传递的消息都是纯文本(字符串)**，而且且文本格式必须按照http协议规定的格式书写



## 请求的消息格式

请求消息格式有三部分组成

![image-20250614175125788](./assets/image-20250614175125788.png)

### 请求行

高度概括了客户端想要干什么
请求行是整个http报文的第一行字符串，它包含三个部分：**请求方法、路径+参数+hash、协议和版本**

#### 请求方法

是一个单词，它表达了客户端的「动作」，比如：`GET`获取、`POST`提交
**在http协议中，并没有规定只能使用上面两种动作，甚至没有规定每种动作会带来怎样的变化**
而在实际的应用中，我们逐渐有了一些约定俗成的规范：

1. 动作通常有：GET(获取资源)、POST(提交消息)、PUT(修改数据)、DELETE(删除数据)
2. **`GET`和`DELETE`请求没有请求体，而`POST`和`PUT`请求可以有请求体**

> [!IMPORTANT]
>
> 浏览器遵循了上面的规范，这带来了`GET`和`POST`的诸多区别
> 比如，**由于`GET`请求没有请求体，所以要传递数据只能把数据放到url的参数中**
> 例如`http://www.xxx.com/news?page=1&size=10`中，`page=1&size=10`就是查询字符串参数

在浏览器中，获取数据一般使用的都是`GET`请求，比如：

- 在地址栏输入地址并按下回车
- 点击了某个a元素
- 获取图片、音频、视频
- 获取css、js、字体等文件

事实上，浏览器自动发出的请求基本都是`GET`请求
而`POST`请求需要开发者手动处理，比如在form表单中设置method为`POST`

### 请求头

描述了请求的一些额外信息
**请求头是一系列的键值对**，里面包含了诸多和业务无关的信息
浏览器每次请求服务器都会自动附带很多的请求头，其实这些请求头大部分服务器是不需要的

- `host`：url地址中的主机

- `User-Agent`：客户端的信息描述

- `Content-Type`：请求体的消息是什么格式，**如果没有请求体，这个字段无意义**
  该字段的常见取值为：

  1. `application/x-www-form-urlencoded`
     表示请求体的数据格式和url地址中参数的格式一样

     ```js
     loginId=admin%loginPwd=123123
     ```

  2. `applocation/json`
     标识请求体的数据格式是`json`格式

     ```json
     { "loginId": "admin", "loginPwd": "123123" }
     ```

  3. `multipart/form-data`
     种特殊的请求体格式，上传文件一般选择该格式

### 请求体

包含了要给服务器传递的正文数据，请求体是可以省略的
理论上，请求体可以是任意格式的字符串，但习惯上，服务器普遍能识别以下几种格式：

```js
`application/x-www-form-urlencoded`
`applocation/json`
`multipart/form-data`
```

由于请求体格式的多样性，服务器在分析请求体时可能无法知晓具体的格式，从而不知道如何解析请求体
因此，**服务器往往要求在请求头中附带一个属性`Content-Type`来描述请求体使用的格式**

> [!IMPORTANT]
>
> **请求体中数据的格式，要与请求头中的`Content-Type`的格式保持一致**

## 响应的消息格式

![image-20250617193647326](./assets/image-20250617193647326.png)

### 响应行

响应行是整个响应字符串的第一行
响应行包含两个部分：

- **协议版本**：表示服务器打算和客户端用什么协议通信
- **状态码（状态消息）**：表示服务器对当前请求的表态

通常，状态码和状态消息是一一对应的，比如状态码200的消息就是OK
不同的请求可能会得到不同的状态码，至于到底会得到哪个状态码，由后端程序决定
状态码分为五类：

| 分类 | 分类描述                                       |
| ---- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务端错误，服务器在处理请求的过程中发生了错误 |

通常认为，0 ~ 399之间的状态码都是正常的，其他为不正常
常见的状态码有：

1. `200 OK`：一切正常
2. `301 Moved Permanently`：资源已被永久重定向
   请求已收到，但是需要的资源不在这个地址，被永远地移动到一个新的访问地址
   **需要去请求新的地址，新地址放到请求头的`Location`中**
3. `302 Found`：资源被暂时重定向
   请求已收到，但是需要的资源不在这个地址，被暂时地移动到了一个新的地址
   **需要去请求新的地址，新地址放到请求头的`Location`中**
4. `304 Not Modified`：文档内容未被修改（缓存）
   请求已收到，请求的资源内容和之前是一样的，用之前请求的结果
5. `400 Bad Resuest`：语义错误，当前请求服务端无法理解和处理
6. `403 Forbidden`：服务器拒绝执行，一般理解为没有权限
7. `404 Not Found`：请求的资源不存在，一般是请求路径错误
8. `500 Internal Server Error`：服务器内部错误

### 响应头

和请求头一样，响应头也是由很多个键值对组成的，具体有哪些键值对则完全取决于服务器程序
目前，对我们最重要的键值对是`Content-Type`，它有多种取值，表示响应体的数据类型
在「B/S」模式中，浏览器会自动根据响应头中`Content-Type`的取值，决定如何处理响应体：

1. `text/plain`：普通的纯文本，浏览器通常会将响应体原封不动的显示到页面上
2. `text/html`：html文档，浏览器通常会将响应体作为页面进行渲染
3. `text/javascript`或`application/javascript`：js代码，浏览器通常会使用JS执行引擎将它解析执行
4. `text/css`：css代码，浏览器会将它视为样式表
5. `image/图片格式[webp/jpeg/png/...]`：浏览器会将它视为jpg图片
6. `attachment `：附件，浏览器看到这个类型，通常会触发下载功能
7. 其他`MIME`类型

### 响应体

请求返回的数据及内容



# 浏览器页面处理流程

当在浏览器地址栏中输入一个url地址，并按下回车后，会发生什么？

![image-20250617202544275](./assets/image-20250617202544275.png)

![image-20250617203509707](./assets/image-20250617203509707.png)



# Ajax

浏览器本身就具备网络通信的能力，但在早期，浏览器并没有把这个能力开放给JS
最早是微软在IE浏览器中把这一能力向JS开放，让JS可以在代码中实现发送请求
这项技术在2005年被正式命名为`AJAX (Asynchronous Javascript And XML)`

IE使用了一套API来完成请求的发送，要依靠一个构造函数完成，该构造函数的名称为`XMLHttpRequest`，简称为`XHR`
但由于`XHP API`有着诸多缺陷，在HTML5和ES6发布之后，产生了一套更完善的API来发送请求
这套API主要使用的是一个叫做`fetch`的函数，因此这套API又称之`Fetch API`

> [!NOTE]
>
> 无论是`XHR`还是`Fetch`，它们都是实现Ajax的技术手段，两者只是不同的API



## XHR

```js
// 创建发送请求的对象
const xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  // 当请求状态发生改变时运行的函数
  // xhr.readyState：一个数字，用于判断请求到了哪个阶个段
  // 1：open方法已被调用
  // 2：send方法已被调用
  // 3：正在接收服务器的响应消息体
  // 4：服务器响应的所有内容均已接收完毕
  // xhr.responseText：获取服务器响应的消息体文本
  // xhr.getResponseHeader("Content-Type") 获取响应头Content - Type

  xhr.open('GET', 'http://localhost:7001/api/herolisst') // 配置请求
  // xhr.setRequestHeader('Content-Type', 'application/json') 设置请求头
  xhr.send(null) // 构建请求体，发送到服务器，如果没有请求体，传递null
}
```

## Fetch

```js
// fetch 返回的是一个 Promise， 当收到服务器的响应头之后，Promise完成 
// 完成之后，会给予一个响应对象
fetch('http://localhost:7001/api/herolist')
	.then((resp) => resp.json()) // 等待 响应头 返回
	.then((resp) => { // 等待 响应体 完成返回
		console.log(resp.data)
	})
```



# cookie

为什么要有cookie？cookie是什么？
