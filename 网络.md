# 客户端&服务器

在大部分情况下，通信总是由一方发出一个消息开始，而另一方回复一个消息结束
发出消息的一方称之为**客户端**`Client`，发出消息的过程称之为请求`Request`
回复消息的一方称之为**服务器**`Server`，回复消息的过程称之为响应`Response`

![image-20250614153552168](./assets/image-20250614153552168.png)

> [!NOTE]
>
> **不管是客户端，还是服务器，它们都是一个应用程序，而不是一台计算机**
> **客户端和服务器可以分布在不同的计算机上，也可以在同一台计算机上**
> 例如`liveserver`插件和`http.createServer`，就是一个服务器，它运行在本地的计算机上
>
> 大部分后端开发的就是服务器程序，前端的`NodeJs`技术也能开发服务器程序
>
> 客户端和服务器的这种交互模式称之为「经典C/S结构」，如果客户端是浏览器则称之为「B/S结构」
>
> 服务器程序往往是为互联网产品提供服务，因此又称之为`web`服务器
>
> **一次完整的交互，总是从请求开始，响应结束**



# 地址`url`

在互联网中，我们可以通过一个叫`url`地址的东西找到我们想要的资源
`url`全称`uniform resource locator`，**统一资源定位符**
它是一个字符串，用于表达互联网中某个资源的位置

![image-20250614162350029](./assets/image-20250614162350029.png)



## 协议`protocol`

### `http`

通过url地址，能够在茫茫互联网中准确的找到自己想要的服务
但光找到服务还是不够，双方需要「用同一种语言」来对话，否则都听不懂对方在说什么
这个「语言」就是协议，而互联网中最常见的协议就是`http`协议
`http`是基于「请求-响应」的方式完成通信的，每一次通信都是由客户端向服务器发出请求，传递一些消息过去，然后经过服务器程序处理后，响应给客户端一些消息
协议规定：

- 每次「请求-响应」都是独立的，相互之间互不干扰，这种模式的协议我们称之为**无状态协议**
- **每次「请求-响应」传递的消息都是纯文本(字符串)**，而且且文本格式必须按照http协议规定的格式书写

### `https`

`https`是在`http`协议基础上发展起来的，它增加了安全性，都基于`TCP`协议
它保证了数据在传输过程中不被窃取和篡改，从而保证传输安全

服务器申请`SSL`加密协议证书，浏览器通过`https`协议访问服务，先会拿到证书签名再验证是否被篡改，验证无误则后则正常通信

![image-20250729161244507](./assets/image-20250729161244507.png)



## 主机`Host`

它表示客户端希望在哪台计算机上寻找资源，有两种写法：`IP`地址和域名

### `IP`地址

由四部分数字组成，每部分数字对应8位二进制数字，各部分之间用小数点分开，如：`211.152.65.112`
网络上的每台主机都分配了一个专门的地址，是唯一的

特殊`IP`地址，`127.0.0.1`它表示本机`IP`地址

### 域名

域名类似`IP`地址的别名，把不容易记忆的数字要为容易记忆的单词
**当使用域名访问时，会自动转换为`IP`地址**
特殊域名`localhost`，它表示的`IP`地址是`127.0.0.1`



## 端口`Port`

它表示客户端希望在哪个应用程序中寻找资源，所有网络通信的应用程序都必须要占有一个端口号
每个服务器程序，都会监听一个或多个端口，只有找到对应的端口，才能找到这个程序
端口号的范围在`0 ～ 65535`，端口号是可选的，若不填写，则：

- 如果使用的是`http`协议，默认端口号为`80`
- 如果使用的是`https`协议，默认端口号为`443`



## 路径`Path`

服务器上往往有许许多多的资源，每个资源都有自己的访问路径
路径是可选的，若不写，则为`/`



## 参数`Query/Params`

某些资源可以根据需要呈现不同的内容，比如一篇新闻列表的页面，可以指定它呈现第几页的新闻
而「第几页」就属于一些额外信息，这些额外信息可以通过参数传递

```js
// 查询参数(Query)：page=1&limit=10
const url = 'http://duyiedu.com/news?page=1&limit=10'

// 路径参数(Url Params)：34767253，服务器中路由匹配规则为：`/news/:id`
const url = 'http://duyiedu.com/news/34767253'
```



## `hash`

在网络通信中，`hash`没有什么用，它往往作为浏览器的锚链接出现



## 请求的消息格式

请求消息格式有三部分组成

![image-20250614175125788](./assets/image-20250614175125788.png)

### 请求行

高度概括了客户端想要干什么
请求行是整个http报文的第一行字符串，它包含三个部分：**请求方法、路径+参数+hash、协议和版本**

请求方法：是一个单词，它表达了客户端的「动作」，比如：`GET`获取、`POST`提交
**在http协议中，没有规定只能使用上面两种动作，甚至没有规定每种动作会带来怎样的变化，只有语义上的差别**
而在实际的应用中，我们逐渐有了一些约定俗成的规范：

1. 动作通常有：GET(获取资源)、POST(提交消息)、PUT(修改数据)、DELETE(删除数据)
2. **`GET`和`DELETE`请求体为空，而`POST`和`PUT`请求可以有请求体**

> [!IMPORTANT]
>
> 浏览器遵循了上面的规范，这带来了`GET`和`POST`的诸多区别
> 比如，**由于`GET`请求体为空，所以要传递数据只能把数据放到url的参数中**
> 例如`http://www.xxx.com/news?page=1&size=10`中，`page=1&size=10`就是查询字符串参数
>
> **`GET`请求体为空，但不能没有**
> 即请求头后必须要有两个换行，否侧请求是不完整的，再后面才是请求体，请求体为空可以不写
>
> ```js
> 请求行
> 请求头
> 
> 请求体
> ```

在浏览器中，获取数据一般使用的都是`GET`请求，比如：

- 在地址栏输入地址并按下回车
- 点击了某个a元素
- 获取图片、音频、视频
- 获取css、js、字体等文件

事实上，浏览器自动发出的请求基本都是`GET`请求
而`POST`请求需要开发者手动处理，比如在form表单中设置method为`POST`

### 请求头

描述了请求的一些额外信息
**请求头是一系列的键值对**，里面包含了诸多和业务无关的信息
浏览器每次请求服务器都会自动附带很多的请求头，其实这些请求头大部分服务器是不需要的

- `host`：url地址中的主机

- `User-Agent`：客户端的信息描述

- `Content-Type`：请求体的消息是什么格式，**如果没有请求体，这个字段无意义**
  该字段的常见取值为：

  1. `application/x-www-form-urlencoded`
     表示请求体的数据格式和url地址中参数的格式类似

     ```js
     loginId=admin%loginPwd=123123
     ```

  2. `applocation/json`
     标识请求体的数据格式是`json`格式

     ```json
     { "loginId": "admin", "loginPwd": "123123" }
     ```

  3. `multipart/form-data`
     种特殊的请求体格式，上传文件一般选择该格式

### 请求体

包含了要给服务器传递的正文数据，请求体是可以省略的
理论上，请求体可以是任意格式的字符串，但习惯上，服务器普遍能识别以下几种格式：

```js
`application/x-www-form-urlencoded`
`applocation/json`
`multipart/form-data`
```

由于请求体格式的多样性，服务器在分析请求体时可能无法知晓具体的格式，从而不知道如何解析请求体
因此，**服务器往往要求在请求头中附带一个属性`Content-Type`来描述请求体使用的格式**

> [!IMPORTANT]
>
> **请求体中数据的格式，要与请求头中的`Content-Type`的格式保持一致**



## 响应的消息格式

![image-20250617193647326](./assets/image-20250617193647326.png)

### 响应行

响应行是整个响应字符串的第一行
响应行包含两个部分：

- **协议版本**：表示服务器打算和客户端用什么协议通信
- **状态码（状态消息）**：表示服务器对当前请求的表态

通常，状态码和状态消息是一一对应的，比如状态码200的消息就是OK
不同的请求可能会得到不同的状态码，至于到底会得到哪个状态码，由后端程序决定
状态码分为五类：

| 分类 | 分类描述                                       |
| ---- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务端错误，服务器在处理请求的过程中发生了错误 |

通常认为，0 ~ 399之间的状态码都是正常的，其他为不正常
常见的状态码有：

1. `200 OK`：一切正常
2. `301 Moved Permanently`：资源已被永久重定向
   请求已收到，但是需要的资源不在这个地址，被永远地移动到一个新的访问地址
   **需要去请求新的地址，新地址放到请求头的`Location`中**
3. `302 Found`：资源被暂时重定向
   请求已收到，但是需要的资源不在这个地址，被暂时地移动到了一个新的地址
   **需要去请求新的地址，新地址放到请求头的`Location`中**
4. `304 Not Modified`：文档内容未被修改（缓存）
   请求已收到，请求的资源内容和之前是一样的，用之前请求的结果
5. `400 Bad Resuest`：语义错误，当前请求服务端无法理解和处理
6. `403 Forbidden`：服务器拒绝执行，一般理解为没有权限
7. `404 Not Found`：请求的资源不存在，一般是请求路径错误
8. `500 Internal Server Error`：服务器内部错误

### 响应头

和请求头一样，响应头也是由很多个键值对组成的，具体有哪些键值对则完全取决于服务器程序
目前，对我们最重要的键值对是`Content-Type`，它有多种取值，表示响应体的数据类型
在「B/S」模式中，浏览器会自动根据响应头中`Content-Type`的取值，决定如何处理响应体：

1. `text/plain`：普通的纯文本，浏览器通常会将响应体原封不动的显示到页面上
2. `text/html`：html文档，浏览器通常会将响应体作为页面进行渲染
3. `text/javascript`或`application/javascript`：js代码，浏览器通常会使用JS执行引擎将它解析执行
4. `text/css`：css代码，浏览器会将它视为样式表
5. `image/图片格式[webp/jpeg/png/...]`：浏览器会将它视为jpg图片
6. `attachment `：附件，浏览器看到这个类型，通常会触发下载功能
7. 其他`MIME`类型

### 响应体

请求返回的数据及内容，格式和响应头中的`Content-Type`相对应



# `Cookie`

`cookie`是浏览器中特有的一个概念，它就像浏览器的专属卡包，管理着各个网站的身份信息

**`cookie`的特点**：保存在浏览器端的小型文本数据，请求自动携带，服务器可控
**`cookie`的缺点**：只能以字符串格式储存、存储量有限（单个请求限制在`4KB`左右）、数据容易被窃取篡改和丢失



## 为什么要有`cookie`？

本质是为无状态的`HTTP`协议 “增加记忆能力”，让服务器能够识别客户端、保留状态信息



## `cookie`信息

每个`cookie`就相当于是属于某个网站的一个卡片，记录了以下信息：

- `key`：键，比如「身份编号」

- `value`：值，比如身份编号「1456BC95」，这有点像卡片的条形码，当然它可以是任何信息

- `domain`：域，表达这个`cookie`是属于哪个网站的，匹配规则如下：

  ```js
  domain = `bilibili.com`
  // 可以匹配：'bilibili.com' 'www.bilibili.com' ...
  
  domain = `www.bilibili.com`
  // 就只能匹配 'www.bilibili.com'
  ```

- `path`：路径，表示`cookie`是属于该网站的哪个路径的，不满足该路径的请求不会携带该`cookie`

  ```js
  比如`cookie`中的`path`是`/news`
  则可以匹配的请求路径可以是`/news`、`/news/detail`、`/news/a/b/c`等,但不能匹配`/blogs`
  
  如果`path`是`/`，则该域名下所有路径都可以匹配
  ```

- `secure`：是否使用安全传输

  ```js
  `cookie`中有`secure`，则请求协议必须是`https`，否则不会发送该`cookie`
  `cookie`中没有该属性，则请求协议可以是`http`，也可以是`http`
  ```

- `expire`：过期时间，表示该`cookie`在什么时候过期

- `httpOnly`：禁止客户端通过`JavaScript document.cookie`访问该 `cookie`，防止`XSS`跨站脚本攻击窃取

- `sameSite`：限制第三方请求携带`cookie`，防止`CSRF`跨站请求伪造，取值：

  ```js
  `Strict`: 仅同站请求携带
  `Lax`: 部分跨站请求允许，默认值
  `None`: 允许所有请求，但需配合`Secure`属性
  ```



## 携带`cookie`

当浏览器向服务器发送一个请求的时候，会检查`cookie`卡包，看看哪些适合附带发送给服务器
那么满足哪些条件下，浏览器的请求会附带这个`cookie`呢？

1. `cookie`没有过期
2. `cookie`中的域和这次请求的域是匹配的，`cookie`不在乎端口，只要域匹配即可
3. `cookie`中的`path`和这次请求的`path`是匹配的
4. 验证`cookie`的安全传输`secure`

如果一个`cookie`满足了上述的所有条件
**浏览器会将符合条件的`cookie`的键值按照`key=value`自动放置到这次请求的请求头中**
`cookie`中包含了重要的身份信息，所以不能泄露，否则可以通过`cookie`伪造身份信息



## 设置`cookie`

### 服务器响应

这种模式是非常普遍的，服务器会在响应的消息中包含`cookie`，浏览器会自动的把`cookie`保存到卡包中
如果已经存在`key、path、domain`属性都相同的`cookie`了，则自动覆盖之前的设置

```yaml
# 服务器可以通过设置响应头，来告诉浏览器应该如何设置`cookie`

Set-Cookie: cookie_1
Set-Cookie: cookie_2
...
```

通过这种方法，就可以在一次响应中设置多个`cookie`，每个`cookie`格式如下

```js
键=值; path=?; domain=?; expire=?; max-age=?; secure; httponly
```

**每个`cookie`中，除了`键=值`是必须要设置的，其他的属性都是可选的，且顺序不限**

- `path`：如果服务器不设置，浏览器会自动设置为当前请求的路径

- `domain`：如果服务器不设置，浏览器会自动设置为当前请求的域名

  > 如果设置了无效的域，浏览器是不认可的，即`domain`的值与请求的域名都不一样

- `expire`：设置`cookie`的过期时间，必须是一个有效的`GMT`时间，即格林威治标准时间字符串

  > 例如`Wed, 06 Aug 2025 08:53:34 GMT`，**客户端达到这个事件后自动销毁该`cookie`**

- `max-age`：设置`cookie`的有效时间，单位为秒，通常`expire`和`max-age`设置一个就行

  > 如果既不设置`expire`，也不设置`max-age`属性，则浏览器窗口关闭后就失效

- `secure`：是否是安全连接，如果设置了该值，则请求必须为`https`协议

- `httponly`：设置`cookie`是否仅能用于传输，不能客户端通过JS获取

  > 如果设置了该值，表示该`cookie`仅能用于传输，而不允许在客户端通过JS获取
  > 例如在`iframe`中获取父级域名的`cookie`，防止跨站脚本攻击`XSS`

于是，只要满足要求，这个`cookie`就会自动附加到请求头的`cookie`中

```yaml
Cookie: token=12345; key=value; 其他cookie ...
```

服务器如何删除浏览器的一个`cookie`？
**只需要让服务器响应一个`key、domain、path`相同，但是时间过期的`cookie`即可**
**所以，删除`cookie`其实就是修改`cookie`**

```yaml
# 原来的cookie
token=12345; domain=yuanjin.tech; path=/; max-age=3600
# 设置时间过期，浏览器自动销毁
Set-Cookie: token=; domain=yuanjin.tech; path=/; max-age=-1
```



### 客户端设置

因为`cookie`是存放在浏览器端的，所以浏览器向JS公开了接口让其可以设置

```js
document.cookie = '键=值; path=?; domain=?; expire=?; max-age=?; secure'
```

客户端设置`cookie`有几点不同：

- 没有`httponly`，因为`httponly`就是为了限制在客户端访问的，所以在客户端配置失去了限制的意义
- `path`在客户端设置时的默认值是当前网页的`path`
- `domain`的默认值是当前网页的`domain`域名

客户端删除`cookie`和服务器也一样，修改`cookie`的过期时间即可



# `Session`

与`Cookie`类似，同样可以解决`HTTP`请求无状态的问题

**`Session`的优点：**

- 数据存储在服务端，安全性和可控性高，数据难以被获取和篡改
- 数据存储没有大小限制（看服务器硬盘容量），并且类型可以是任何格式

**`Session`的缺点：**

- 占用服务器资源，增加存储成本（在高并发场景下尤为明显）





# 跨域

指浏览器从一个域名的网页去请求另一个域名的资源时，由于浏览器的安全限制（同源策略）而产生的限制或错误
因此，跨域只在浏览器环境中发生



## 同源策略`Same-Origin Policy`

指的是两个URL地址的**协议、域名、端口**三者完全一致，只要有一个不同，就是不同源，则会产生跨域

跨域限制的核心就是浏览器的同源策略，这是一种安全机制，目的是**防止恶意网站窃取另一个网站的敏感数据**
所以一般情况下，浏览器不允许使用不同源的数据



## `JSONP`

利用`<script>`标签不受同源策略限制的特性，达到跨域获取数据，缺陷是仅支持`GET`请求

```js
function jsonp(url, callback) {
  const script = document.createElement('script')
  script.src = url
  document.body.appendChild(script)
  
  script.onload = () => {
    script.remove()
  }
  // 全局定义服务器返回的回调函数
  // 服务器返回的是一段JS代码：执行这个函数，函数的参数是服务器返回的数据
  window[callback] = function (data) {
    console.log(data)
    delete window[callback]
  }
}

const callbackName = 'handleResponse'
jsonp(`http://localhost:5000/api/jsonp?callback=${callbackName}`)
```

```js
// 服务器端代码 (Express)
app.get('/api/jsonp', (req, res) => {
  // 获取回调函数名
  const callback = req.query.callback
  // 要返回的数据
  const data = { message: '这是JSONP返回的数据' }
  // 构造JSONP响应
  const response = `${callback}(${JSON.stringify(data)})`
  // 设置Content-Type
  res.setHeader('Content-Type', 'application/javascript')
  // 返回数据
  res.send(response)
})
```



## 跨域资源共享`CORS`

跨域资源共享`Cross-Origin Resource Sharing`，是基于`HTTP1.1`的一种跨域解决方案
核心思路是**如果浏览器要跨域访问服务器的资源，需要获得服务器的允许**
**服务器在响应头中添加特定字段，声明允许哪些源、方法、头信息的跨域请求，浏览器验证通过后允许前端访问响应**

当浏览器端运行了一段`Ajax`代码，无论是使用`XHR`还是`Fetch`，浏览器会首先判断它属于哪一种请求模式
针对不同的请求，`CORS`规定了三种不同的交互模式，分别是：

- 简单请求
- 需要预检的请求
- 附带身份凭证的请求

这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格



### 简单请求

当请求同时满足以下条件时，浏览器会认为它是一个简单请求：

- 请求方法为`GET | POST | HEAD`中的一种

- 请求头仅包含安全的字段，常见安全字段如下👇

  `Accept`、`Accept-Language`、`Content-Language`、`Content-Type`、`DPR`、`DownLink`、

  `Save-Data`、`Vieweport-Width`、`Width`

- 如果包含`Content-Type`字段，其值仅限以下3种：

  `text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`

```js
// 简单请求
fetch('http://cors_test.com/api')
// 请求方法不满足，不是简单请求
fetch('http://cors_test.com/api', { method: 'PUT' })
// 有额外非安全字段的请求头字段，不是
fecth('http://cors_test.com/api', { headers: { a: 1 } })
// 请求头中`content-type`字段的值不满足，不是
fetch('http://cors_test.com/api', {
  method: 'POST', headers: { 'content-type': 'application/json' }
})
```

当浏览器判定某个`Ajax`跨域请求为简单请求时👇

- 请求头中自动添加`Origin`字段，值为请求源地址，告诉服务器是哪个地址在跨域请求
- 服务器收到请求后，如果允许该请求跨域，响应头中应该包含`Accecc-Control-Allow-Origin`字段
  - `*`：表示允许任何请求跨域
  - `具体的源地址`：例如`http://my.com`，则表示只允许该地址的请求跨域

为了避免后续的麻烦，强烈推荐响应具体的源，而不是`*`



### 预检请求

如果浏览器不认为这是一种简单请求，就会按照下面面的流程进行👇

```js
// 这个请求就不是一个简单请求
fetch('http://cors_test.com/api', {
  method: 'POST',
  headers: { a: 1, b: 2, 'content-type': 'application/json' },
  body: JSON.stringify({ name: 'Kyle' })
})
```

1. 浏览器发送预检请求，询问服务器是否允许，有以下特征

   - 请求方法为`OPTIONS`
   - 没有请求体、消息体、响应头
   - 请求头中包含：
     - `Origin`：跨域请求的源地址
     - `Access-Control-Request-Method`：后续真实请求将使用的请求方法
     - `Access-Control-Request-Headers`：后续真实请求会改动的请求头

   ```http
   OPTIONS /api HTTP1.1
   Origin: http://cors_test.com
   Access-Control-Request-Method: POST
   Access-Control-Request-Headers: a, b, content-type
   ```

2. 服务器收到预检请求后，如果允许，需要在响应头中添加

   ```js
   // 允许跨域的源
   res.header('access-control-allow-origin', req.headers.origin)
   // 允许后续真实请求的请求方法
   res.header('access-control-allow-methods', 'GET, POST, PUT, DELETE')
   // 允许改动的请求头
   res.header('access-control-allow-headers', 'Content-Type, a, b')
   // 告诉浏览器在多少秒内，对于同样的请求源、方法、请求头，都不需要再次发送预检请求
   res.header('access-control-max-age', 1000 * 60 * 60 * 24 * 7)
   ```

3. 预检请求被允许后，浏览器会发送真实请求

4. 服务器完成真实的响应，响应头中要包含`Access-Control-Allow-Origin`字段

![image-20250807194247859](./assets/image-20250807194247859.png)



### 凭证请求

默认情况下，`Ajax`的跨域请求并不会自动附带`cookie`，这样某些需要权限的操作就无法进行

```js
// xhr
const xhr = new XMLHttpRequest()
xhr.withCredentials = true

// fetch
fetch(url, {
  credentials: 'include'
})

// 两种api的简单配置，即可实现跨域请求附带cookie
```

服务器响应时，也需要在响应头中添加

```js
Access-Gontrol-Allow-Credentials: true
```

对于一个附带身份凭证的请求，若服务器没设置允许携带凭证，浏览器仍然视为跨域而被拒绝
另外要特别注意的是：对于附带身份凭证的请求，服务器不得设置`Access-Control-Allow-Origin: *`



### 封装允许跨域中间件

```js
const allowOrigin = [ 'http://127.0.0.1:5500' ]
module.exports = (req, res, next) => {
  const origin = req.headers.origin

  // 处理预检请求
  if (req.method === 'OPTIONS') {
    res.header('access-control-allow-methods', req.headers['access-control-request-method'])
    res.header('access-control-allow-headers', req.headers['access-control-request-headers'])
    res.header('access-control-max-age', 1000 * 60 * 60 * 24 * 7)
  }

  // 允许跨域请求携带凭证
  res.header('access-control-allow-credentials', true) 

  // 处理简单请求
  if (origin && allowOrigin.includes(origin)) {
    res.header('access-control-allow-origin', origin)
  }
  next()
}
```



## 代理服务器

## `iframe`





# 浏览器页面处理流程

当在浏览器地址栏中输入一个url地址，并按下回车后，会发生什么？

![image-20250617202544275](./assets/image-20250617202544275.png)

![image-20250617203509707](./assets/image-20250617203509707.png)



# Ajax

浏览器本身就具备网络通信的能力，但在早期，浏览器并没有把这个能力开放给js
最早是微软在IE浏览器中把这一能力向js开放，让js可以在代码中实现发送请求
这项技术在2005年被正式命名为`AJAX (Asynchronous Javascript And XML)`

IE使用了一套API来完成请求的发送，要依靠一个构造函数完成，该构造函数的名称为`XMLHttpRequest`，简称为`XHR`
但由于`XHR API`有着诸多缺陷，在`HTML5`和`ES6`发布之后，产生了一套更完善的API来发送请求
这套API主要使用的是一个叫做`fetch`的函数，因此又称`Fetch API`

> [!NOTE]
>
> 无论是`XHR`还是`Fetch`，它们都是实现Ajax的技术手段，两者只是不同的`API`



## `XHR`

```js
// 创建发送请求的对象
const xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  // 当请求状态发生改变时运行的函数
  // xhr.readyState：一个数字，用于判断请求到了哪个阶个段
  // 1：open方法已被调用
  // 2：send方法已被调用
  // 3：正在接收服务器的响应消息体
  // 4：服务器响应的所有内容均已接收完毕
  // xhr.responseText：获取服务器响应的消息体文本
  // xhr.getResponseHeader("Content-Type") 获取响应头Content - Type

  xhr.open('GET', 'http://localhost:7001/api/herolisst') // 配置请求
  // xhr.setRequestHeader('Content-Type', 'application/json') 设置请求头
  xhr.send(null) // 构建请求体，发送到服务器，如果没有请求体，传递null
}
```



## `Fetch`

`XHR`的问题：

- 所有的功能全部集中在同一个对象上，容易书写出混乱不易维护的代码
- 采用传统的事件驱动模式，无法适配新的`Promise API`

`Fetch API`的特点

- 并非取代`AJAX`，而是对`AJAX`传统`XHR API`的改进
- 精细的功能分割：头部信息、请求信息、响应信息等均分布到不同的对象，更利于处理各种复杂的场景
- 使用`Promise API`，更利于异步代码的书写
- `Fetch API`并非`ES6`的内容，属于`HTML5`新增的`Web API`
- `fetch()`返回的是一个`Promise`对象，当收到服务器的响应头之后，`Promise`完成 

语法：`fetch(url, options)`，其中`options`可选

- `url`：想要获取的资源的地址
- `options`：请求配置对象，[完整配置文档](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit)
  - `method`：请求方式，默认值`GET`
  - `headers`：请求头对象
  - `body`：请求体内容，格式必须和请求头中的`Content-Type`的值保持一致
  - `mode`：字符串，请求模式
    - `same-origin`：禁止跨源请求，表示请求必须在同源中发生，否则就会报错
    - `cors`：默认值，设置为该值，会在请求头中加入`origin`和`referer`
    - `no-cors`：设置为该值，不会在请求头中加入`origin`和`referer`，请求跨域时可能会出现问题
  - `credentials`：如何携带`cookie`凭证
    - `omit`：默认值，不携带
    - `same-origin`：请求同源地址时携带
    - `include`：任何请求地址都会携带
  - `cache`：配置请求缓存模式
    - `default`：表示`fetch`请求之前将检查一下`http`缓存
    - `no-store`：直接从远程服务器获取资源，不会先检查`http`缓存，并且拿到响应后也不会更新缓存
    - `reload`：直接从远程服务器获取资源，不会先检查`http`缓存，但是拿到响应后会更新缓存
    - `no-cache`：如果存在匹配的缓存？无论缓存是否过期，都会向远程服务器发出条件请求
      如果服务器表明资源没有变化：将从缓存中返回该资源，有变化：从服务器下载资源并更新缓存
      如果没有缓存？发出普通请求，并使用下载的资源更新缓存
    - `force-cache`：如果有匹配项缓存？无论是否过期都将从缓存中返回
      如果没有缓存？发出普通请求，并使用下载的资源更新缓存
    - `only-if-cached`：如果有匹配项缓存？无论是否过期都将从缓存中返回
      如果没有缓存？则返回网络错误

### `Request`对象

除了使用基本的`fetch`方法，还可以通过创建一个`Request`对象来完成请求
实际上，`fetch`的内部会帮你创建一个`Request`对象

```js
const url = 'http://xxx.com:1234/api'
/** 普通写法 **/
fetch(url, options)

/** Request 写法 **/
const req = new Request(url, options)
fetch(req)

// 注意：尽量保证每次请求都是一个新的`Request`对象
// 或者
// 使用 .clone() 获取一份克隆的`Request`对象
req.clone()
```

### `Response`对象

- `ok`：当响应消息码在`200~299`之间时为`true`，其他为`false`
- `status`：响应状态码
- `text()`：用于处理文本格式的响应
  从响应中获取文本流并将其读完，然后返一个被解决为`string`的`Promise`
- `blob()`：用于处理二进制文件格式（比如图片或者电子表格）的响应
  读取文件的原始数据，一旦读取完整个文件，返回一个被解决为`blob`对象的`Promise`
- `json()`：用于处理`JSON`格式的的响应
  它将`JSON`数据流转换为一个被解决为`Javascript`对象的`Promise`
- `redirect()`：可以用于重定向到另一个URL
  它会创建一个新的`Promise`，以解决来自重定向的URL的响应

```js
(() => {
  const response = await fetch('http://localhost:7001/api/herolist') // 等待 响应头 返回
  const result = await response.json() // 等待 响应体 完成返回
  console.log(result)
})()

// 也可以手动构建 Response 对象，用于模拟网络请求
const response = new Response(`
	{ "id": 1, "name": "北京" },
	{ "id": 2, "name": "上海" },
`, {
  ok: true,
  status: 200
})
```

### `Headers`对象

在`Request`和`Response`对象内部，会将传递的请求头对象，转换为`Headers`

```js
// 构建 headers
const headers = new Headers({
  'Content-Type': 'applocation/json',
  'custom-key': '123456'
})
const req = new Request(url, {
  headers
})
fetch(req)

// 获取 headers
// - .has(key) headers.has(key) 检查请求头中是否存在指定的key值
// - .get(key) 得到请求头中对应的key值
// - .set(key, value) 修改对应的键值对
// - .append(key, value) 添加对应的键值对
// - .keys() 得到所有的请求头键的集合
// - .values() 得到所有的请求头中的值的集合
// - .entries() 得到所有请求头中的键值对的集合
```

