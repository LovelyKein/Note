# 客户端&服务器

在大部分情况下，通信总是由一方发出一个消息开始，而另一方回复一个消息结束
发出消息的一方称之为**客户端**`Client`，发出消息的过程称之为请求`Request`
回复消息的一方称之为**服务器**`Server`，回复消息的过程称之为响应`Response`

![image-20250614153552168](./assets/image-20250614153552168.png)

> [!NOTE]
>
> **不管是客户端，还是服务器，它们都是一个应用程序，而不是一台计算机**
> **客户端和服务器可以分布在不同的计算机上，也可以在同一台计算机上**
> 例如`liveserver`插件和`http.createServer`，就是一个服务器，它运行在本地的计算机上
>
> 大部分后端开发的就是服务器程序，前端的`NodeJs`技术也能开发服务器程序
>
> 客户端和服务器的这种交互模式称之为「经典C/S结构」，如果客户端是浏览器则称之为「B/S结构」
>
> 服务器程序往往是为互联网产品提供服务，因此又称之为`web`服务器
>
> **一次完整的交互，总是从请求开始，响应结束**



# 地址`url`

在互联网中，我们可以通过一个叫`url`地址的东西找到我们想要的资源
`url`全称`uniform resource locator`，**统一资源定位符**
它是一个字符串，用于表达互联网中某个资源的位置

![image-20250614162350029](./assets/image-20250614162350029.png)



## 协议`protocol`

### `http`

通过url地址，能够在茫茫互联网中准确的找到自己想要的服务
但光找到服务还是不够，双方需要「用同一种语言」来对话，否则都听不懂对方在说什么
这个「语言」就是协议，而互联网中最常见的协议就是`http`协议
`http`是基于「请求-响应」的方式完成通信的，每一次通信都是由客户端向服务器发出请求，传递一些消息过去，然后经过服务器程序处理后，响应给客户端一些消息
协议规定：

- 每次「请求-响应」都是独立的，相互之间互不干扰，这种模式的协议我们称之为**无状态协议**
- **每次「请求-响应」传递的消息都是纯文本(字符串)**，而且且文本格式必须按照http协议规定的格式书写

### `https`

`https`是在`http`协议基础上发展起来的，它增加了安全性，其他和`http`协议完全一致
它保证了数据在传输过程中不被窃取和篡改，从而保证传输安全

服务器申请`SSL`加密协议证书，浏览器通过`https`协议访问服务，先会拿到证书签名再验证是否被篡改，验证无误则后面正常通信

![image-20250729161244507](./assets/image-20250729161244507.png)



## 主机`Host`

它表示客户端希望在哪台计算机上寻找资源，有两种写法：`IP`地址和域名

### `IP`地址

特殊`IP`地址，`127.0.0.1`它表示本机`IP`地址

### 域名

域名类似`IP`地址的别名，把不容易记忆的数字要为容易记忆的单词
**当使用域名访问时，会自动转换为`IP`地址**
特殊域名`localhost`，它表示的`IP`地址是`127.0.0.1`



## 端口`Port`

它表示客户端希望在哪个应用程序中寻找资源
每个服务器程序，都会监听一个或多个端口，只有找到对应的端口，才能找到这个服务器程序
端口号是可选的，若不填写，则：

- 如果使用的是`http`协议，默认端口号为`80`
- 如果使用的是`https`协议，默认端口号为`443`



## 路径`Path`

服务器上往往有许许多多的资源，每个资源都有自己的访问路径
路径是可选的，若不写，则为`/`



## 参数`Query/Param`

某些资源可以根据需要呈现不同的内容，比如一篇新闻列表的页面，可以指定它呈现第几页的新闻
而「第几页」就属于一些额外信息，这些额外信息可以通过参数传递

```js
// 访问一个新闻列表的页面，同时希望它展示第5页，每页展示10条新闻，可得到下面的 url地址：
const url = 'http://duyiedu.com/news?page=1&limit=10'
```



## `hash`

在网络通信中，`hash`没有什么用，它往往作为浏览器的锚链接出现



## 请求的消息格式

请求消息格式有三部分组成

![image-20250614175125788](./assets/image-20250614175125788.png)

### 请求行

高度概括了客户端想要干什么
请求行是整个http报文的第一行字符串，它包含三个部分：**请求方法、路径+参数+hash、协议和版本**

请求方法：是一个单词，它表达了客户端的「动作」，比如：`GET`获取、`POST`提交
**在http协议中，没有规定只能使用上面两种动作，甚至没有规定每种动作会带来怎样的变化，只有语义上的差别**
而在实际的应用中，我们逐渐有了一些约定俗成的规范：

1. 动作通常有：GET(获取资源)、POST(提交消息)、PUT(修改数据)、DELETE(删除数据)
2. **`GET`和`DELETE`请求体为空，而`POST`和`PUT`请求可以有请求体**

> [!IMPORTANT]
>
> 浏览器遵循了上面的规范，这带来了`GET`和`POST`的诸多区别
> 比如，**由于`GET`请求体为空，所以要传递数据只能把数据放到url的参数中**
> 例如`http://www.xxx.com/news?page=1&size=10`中，`page=1&size=10`就是查询字符串参数
>
> **`GET`请求体为空，但不能没有**
> 即请求头后必须要有两个换行，否侧请求是不完整的，再后面才是请求体，请求体为空可以不写
>
> ```js
> 请求行
> 请求头
> 
> 请求体
> ```

在浏览器中，获取数据一般使用的都是`GET`请求，比如：

- 在地址栏输入地址并按下回车
- 点击了某个a元素
- 获取图片、音频、视频
- 获取css、js、字体等文件

事实上，浏览器自动发出的请求基本都是`GET`请求
而`POST`请求需要开发者手动处理，比如在form表单中设置method为`POST`

### 请求头

描述了请求的一些额外信息
**请求头是一系列的键值对**，里面包含了诸多和业务无关的信息
浏览器每次请求服务器都会自动附带很多的请求头，其实这些请求头大部分服务器是不需要的

- `host`：url地址中的主机

- `User-Agent`：客户端的信息描述

- `Content-Type`：请求体的消息是什么格式，**如果没有请求体，这个字段无意义**
  该字段的常见取值为：

  1. `application/x-www-form-urlencoded`
     表示请求体的数据格式和url地址中参数的格式一样

     ```js
     loginId=admin%loginPwd=123123
     ```

  2. `applocation/json`
     标识请求体的数据格式是`json`格式

     ```json
     { "loginId": "admin", "loginPwd": "123123" }
     ```

  3. `multipart/form-data`
     种特殊的请求体格式，上传文件一般选择该格式

### 请求体

包含了要给服务器传递的正文数据，请求体是可以省略的
理论上，请求体可以是任意格式的字符串，但习惯上，服务器普遍能识别以下几种格式：

```js
`application/x-www-form-urlencoded`
`applocation/json`
`multipart/form-data`
```

由于请求体格式的多样性，服务器在分析请求体时可能无法知晓具体的格式，从而不知道如何解析请求体
因此，**服务器往往要求在请求头中附带一个属性`Content-Type`来描述请求体使用的格式**

> [!IMPORTANT]
>
> **请求体中数据的格式，要与请求头中的`Content-Type`的格式保持一致**



## 响应的消息格式

![image-20250617193647326](./assets/image-20250617193647326.png)

### 响应行

响应行是整个响应字符串的第一行
响应行包含两个部分：

- **协议版本**：表示服务器打算和客户端用什么协议通信
- **状态码（状态消息）**：表示服务器对当前请求的表态

通常，状态码和状态消息是一一对应的，比如状态码200的消息就是OK
不同的请求可能会得到不同的状态码，至于到底会得到哪个状态码，由后端程序决定
状态码分为五类：

| 分类 | 分类描述                                       |
| ---- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务端错误，服务器在处理请求的过程中发生了错误 |

通常认为，0 ~ 399之间的状态码都是正常的，其他为不正常
常见的状态码有：

1. `200 OK`：一切正常
2. `301 Moved Permanently`：资源已被永久重定向
   请求已收到，但是需要的资源不在这个地址，被永远地移动到一个新的访问地址
   **需要去请求新的地址，新地址放到请求头的`Location`中**
3. `302 Found`：资源被暂时重定向
   请求已收到，但是需要的资源不在这个地址，被暂时地移动到了一个新的地址
   **需要去请求新的地址，新地址放到请求头的`Location`中**
4. `304 Not Modified`：文档内容未被修改（缓存）
   请求已收到，请求的资源内容和之前是一样的，用之前请求的结果
5. `400 Bad Resuest`：语义错误，当前请求服务端无法理解和处理
6. `403 Forbidden`：服务器拒绝执行，一般理解为没有权限
7. `404 Not Found`：请求的资源不存在，一般是请求路径错误
8. `500 Internal Server Error`：服务器内部错误

### 响应头

和请求头一样，响应头也是由很多个键值对组成的，具体有哪些键值对则完全取决于服务器程序
目前，对我们最重要的键值对是`Content-Type`，它有多种取值，表示响应体的数据类型
在「B/S」模式中，浏览器会自动根据响应头中`Content-Type`的取值，决定如何处理响应体：

1. `text/plain`：普通的纯文本，浏览器通常会将响应体原封不动的显示到页面上
2. `text/html`：html文档，浏览器通常会将响应体作为页面进行渲染
3. `text/javascript`或`application/javascript`：js代码，浏览器通常会使用JS执行引擎将它解析执行
4. `text/css`：css代码，浏览器会将它视为样式表
5. `image/图片格式[webp/jpeg/png/...]`：浏览器会将它视为jpg图片
6. `attachment `：附件，浏览器看到这个类型，通常会触发下载功能
7. 其他`MIME`类型

### 响应体

请求返回的数据及内容



# 浏览器页面处理流程

当在浏览器地址栏中输入一个url地址，并按下回车后，会发生什么？

![image-20250617202544275](./assets/image-20250617202544275.png)

![image-20250617203509707](./assets/image-20250617203509707.png)



# Ajax

浏览器本身就具备网络通信的能力，但在早期，浏览器并没有把这个能力开放给js
最早是微软在IE浏览器中把这一能力向js开放，让js可以在代码中实现发送请求
这项技术在2005年被正式命名为`AJAX (Asynchronous Javascript And XML)`

IE使用了一套API来完成请求的发送，要依靠一个构造函数完成，该构造函数的名称为`XMLHttpRequest`，简称为`XHR`
但由于`XHR API`有着诸多缺陷，在`HTML5`和`ES6`发布之后，产生了一套更完善的API来发送请求
这套API主要使用的是一个叫做`fetch`的函数，因此又称`Fetch API`

> [!NOTE]
>
> 无论是`XHR`还是`Fetch`，它们都是实现Ajax的技术手段，两者只是不同的`API`



## `XHR`

```js
// 创建发送请求的对象
const xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
  // 当请求状态发生改变时运行的函数
  // xhr.readyState：一个数字，用于判断请求到了哪个阶个段
  // 1：open方法已被调用
  // 2：send方法已被调用
  // 3：正在接收服务器的响应消息体
  // 4：服务器响应的所有内容均已接收完毕
  // xhr.responseText：获取服务器响应的消息体文本
  // xhr.getResponseHeader("Content-Type") 获取响应头Content - Type

  xhr.open('GET', 'http://localhost:7001/api/herolisst') // 配置请求
  // xhr.setRequestHeader('Content-Type', 'application/json') 设置请求头
  xhr.send(null) // 构建请求体，发送到服务器，如果没有请求体，传递null
}
```



## `Fetch`

`XHR`的问题：

- 所有的功能全部集中在同一个对象上，容易书写出混乱不易维护的代码
- 采用传统的事件驱动模式，无法适配新的`Promise API`

`Fetch API`的特点

- 并非取代`AJAX`，而是对`AJAX`传统`XHR API`的改进
- 精细的功能分割：头部信息、请求信息、响应信息等均分布到不同的对象，更利于处理各种复杂的场景
- 使用`Promise API`，更利于异步代码的书写
- `Fetch API`并非`ES6`的内容，属于`HTML5`新增的`Web API`
- `fetch()`返回的是一个`Promise`对象，当收到服务器的响应头之后，`Promise`完成 

语法：`fetch(url, options)`，其中`options`可选

- `url`：想要获取的资源的地址
- `options`：请求配置对象，[完整配置文档](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit)
  - `method`：请求方式，默认值`GET`
  - `headers`：请求头对象
  - `body`：请求体内容，格式必须和请求头中的`Content-Type`的值保持一致
  - `mode`：字符串，请求模式
    - `same-origin`：禁止跨源请求，表示请求必须在同源中发生，否则就会报错
    - `cors`：默认值，设置为该值，会在请求头中加入`origin`和`referer`
    - `no-cors`：设置为该值，不会在请求头中加入`origin`和`referer`，请求跨域时可能会出现问题
  - `credentials`：如何携带`cookie`凭证
    - `omit`：默认值，不携带
    - `same-origin`：请求同源地址时携带
    - `include`：任何请求地址都会携带
  - `cache`：配置请求缓存模式
    - `default`：表示`fetch`请求之前将检查一下`http`缓存
    - `no-store`：直接从远程服务器获取资源，不会先检查`http`缓存，并且拿到响应后也不会更新缓存
    - `reload`：直接从远程服务器获取资源，不会先检查`http`缓存，但是拿到响应后会更新缓存
    - `no-cache`：如果存在匹配的缓存？无论缓存是否过期，都会向远程服务器发出条件请求
      如果服务器表明资源没有变化：将从缓存中返回该资源，有变化：从服务器下载资源并更新缓存
      如果没有缓存？发出普通请求，并使用下载的资源更新缓存
    - `force-cache`：如果有匹配项缓存？无论是否过期都将从缓存中返回
      如果没有缓存？发出普通请求，并使用下载的资源更新缓存
    - `only-if-cached`：如果有匹配项缓存？无论是否过期都将从缓存中返回
      如果没有缓存？则返回网络错误

### `Request`对象

除了使用基本的`fetch`方法，还可以通过创建一个`Request`对象来完成请求
实际上，`fetch`的内部会帮你创建一个`Request`对象

```js
const url = 'http://xxx.com:1234/api'
/** 普通写法 **/
fetch(url, options)

/** Request 写法 **/
const req = new Request(url, options)
fetch(req)

// 注意：尽量保证每次请求都是一个新的`Request`对象
// 或者
// 使用 .clone() 获取一份克隆的`Request`对象
req.clone()
```

### `Response`对象

- `ok`：当响应消息码在`200~299`之间时为`true`，其他为`false`
- `status`：响应状态码
- `text()`：用于处理文本格式的响应
  从响应中获取文本流并将其读完，然后返一个被解决为`string`的`Promise`
- `blob()`：用于处理二进制文件格式（比如图片或者电子表格）的响应
  读取文件的原始数据，一旦读取完整个文件，返回一个被解决为`blob`对象的`Promise`
- `json()`：用于处理`JSON`格式的的响应
  它将`JSON`数据流转换为一个被解决为`Javascript`对象的`Promise`
- `redirect()`：可以用于重定向到另一个URL
  它会创建一个新的`Promise`，以解决来自重定向的URL的响应

```js
(() => {
  const response = await fetch('http://localhost:7001/api/herolist') // 等待 响应头 返回
  const result = await response.json() // 等待 响应体 完成返回
  console.log(result)
})()

// 也可以手动构建 Response 对象，用于模拟网络请求
const response = new Response(`
	{ "id": 1, "name": "北京" },
	{ "id": 2, "name": "上海" },
`, {
  ok: true,
  status: 200
})
```

### `Headers`对象

在`Request`和`Response`对象内部，会将传递的请求头对象，转换为`Headers`

```js
// 构建 headers
const headers = new Headers({
  'Content-Type': 'applocation/json',
  'custom-key': '123456'
})
const req = new Request(url, {
  headers
})
fetch(req)

// 获取 headers
// - .has(key) headers.has(key) 检查请求头中是否存在指定的key值
// - .get(key) 得到请求头中对应的key值
// - .set(key, value) 修改对应的键值对
// - .append(key, value) 添加对应的键值对
// - .keys() 得到所有的请求头键的集合
// - .values() 得到所有的请求头中的值的集合
// - .entries() 得到所有请求头中的键值对的集合
```



# cookie

为什么要有cookie？cookie是什么？
