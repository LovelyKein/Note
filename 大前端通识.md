# 事件循环`EventLoop`



## 浏览器进程模型

何为进程？

程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程
每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意

![image-20250506193049120](./assets/image-20250506193049120.png)

何为线程？

有了进程后，就可以运行程序的代码了，运行代码的「人」称之为「线程」，即运行程序的是线程
**一个进程至少有一个线程**，所以在进程开启后会自动创建一个个线程来运行代码，该线程称之为**主线程**
如果程序需要同时执行多块代码，主线程就会启动更多的线和程来执行代码

![image-20250506193518916](./assets/image-20250506193518916.png)



## 浏览器有哪些进程和线程？

浏览器是一个多进程多线程的应用程序
为了避免相互影响,为了减少连环崩溃的几率,当启动浏览器后,它会自动启动多个进程

![image-20250506193940766](./assets/image-20250506193940766.png)

浏览器最主要的进程有：

- **浏览器进程**

  主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务

- **网络进程**

  负责加载网络资源；网络进程内部会启动多个线程来处理不同的网络任务

- **渲染进程（主要）**

  渲染进程启动后，会开启一个渲染主线程，主线程负责执行`HTML、CSS、JS`代码
  默认情况下，浏览器会为每个标签页开启一个新的渲染进程,以保证不同的标签页之间不相互影响



## 渲染主线程如何工作？

要处理大量的的任务,主线程遇到了一个前所未有的难题：如何调度任务?
渲染主线程想出了一个绝妙的主意来处理这个问题：排队

![image-20250506195951774](./assets/image-20250506195951774.png)

1. 在最开始的时候，渲染主线程会进入一个无限循环
2. 第一次循环会检查消息队列中是否存在任务；如果有，就取出第一个任务执行，执行完一个后进入下一次循环
   如果没有，则进入休眠状态
3. 其他所有线程 (包括其他进程的线程) 可以随时向消息队列添加任务
   新任务会加到消息队列的末尾，在添加新任务时
   如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务

这样一来，就可以让每个任务有条不紊的、持续的进行下去了
整个过程，被称之为**事件循环 (消息循环)**



## 何为异步？

代码在执行过程中,会遇到一些无法立即处理的任务，比如：

- 计时完成后需要执行的任务 --`setTimeout、setinterval`
- 网络通信完成后需要执行的任务 --`XHR、Fetch`
- 用户操作后需要执行的任务 --`addEventListener`

如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」

![image-20250507105222984](./assets/image-20250507105222984.png)

渲染主线程承担着极其重要的工作，无论如何都不能阻塞！
因此，浏览器选择**异步**来解决这个问题

![image-20250507105859557](./assets/image-20250507105859557.png)

使用异步的方式，**渲染主线程永不阻塞**

```js
// 面试题：如何理解 JS 的异步？

参考答案：
JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中,而渲染主线程只有一个
而渲染主线程承担着诸多的工作，渲染页面、执行JS都在其中运行
如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行
这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新,给用户造成卡死现象

所以浏览器采用异步的方式来避免，具体做法是当某些任务发生时,比如计时器、网络、事件监听,主线程将任务交给其他线程去处理
自身立即结束任务的执行，转而执行后续代码
当其他线程完成时，将事先传递的回调函数包装成任务，加入到 消息队列 的末尾排队，等待主线程调度执行
```



## 任务有优先级吗？

**任务没有优先级，在消息队列中先进先出，但消息队列是有优先级的**

```js
// 根据W3C的最新解释：
1. 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列
2. 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行
3. 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行
// https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint
```

在目前`Chrome`浏览器的实现中，至少包含了下面的队列：

- 延时队列：用于存放计时器到达后的回调任务，优先级【中】
- 交互队列：用于存放用户操作后产生的事件处理任务，优先级【高】
- 微队列：用户存放需要最快执行的任务，优先级【最高】

添加任务到微队列的主要方式主要是使用`Promise回调、MutationObserver`

**宏任务`macro task`**：`setTimeout`、`setInterval`、`requestAnimationFrame`、事件处理函数
**微任务`micro task`**：`Promise`的`.then()`和静态方法

```js
// 立即把一个函数添加到微队列等待执行
Promise.resolve().then(函数)
```

**单线程是异步产生的原因，事件循环是异步的实现方式**

> [!NOTE]
>
> `Promise(() => { 代码 })`里的代码是同步执行的
> `.then(callback)`的回调才是异步的，状态确定后将`callback`放进微队列等待执行
>
> `resolve()`和`reject()`后面的代码依旧会运行，只是不会更改任务的状态和数据



# 浏览器如何渲染页面？

当浏览器的网络线程收到HTML文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列
在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程

![image-20250507154541782](./assets/image-20250507154541782.png)

每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入
这样，整个渲染流程就形成了一套组织严密的生产流水线



## 解析 HTML

解析过程中遇到CSS解析CSS
为了提高解析效率，浏览器在开始解析前会启动一个**预解析的线程**，率先下载HTML中的外部CSS文件和外部的JS文件
如果主线程解析到Link标签位置，此时外部的CSS文件还没有下载解析好，主线程不会等待，继续解析后续的HTML
这是因为下载和解析CSS的工作是在预解析线程中进行的，这就是CSS不会阻塞HTML解析的根本原因

![image-20250507171449270](./assets/image-20250507171449270.png)

如果主线程解析到script位置，会停止解析HTML，转而等待JS文件下载好，并将全局代码解析执行完成后，才能继续解析HTML
这是因为JS代码的执行过程可能会修改当前的DOM树，所以DOM树的生成必须暂停
这就是JS会阻塞HTML解析的根本原因

![image-20250507172150605](./assets/image-20250507172150605.png)

HTML解析完成后，会得到DOM树和CSSOM树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在CSSOM树中



## 样式计算

渲染主线程会遍历得到的DOM树，依次为树中的每个节点计算出它最终样式,称之为`ComputedStyle`
在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)，相对单位会变成绝对单位，比如em会变成px
这一步完成后，会得到一棵带有样式的DOM树

![image-20250507173014171](./assets/image-20250507173014171.png)



## 布局

布局阶段会依次遍历DOM树的每一个节点，计算每个节点的几何信息；例如节点的宽高、相对包含块的位置
大部分时候，DOM树和布局树并非一一对应
比如`display: none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然DOM树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中；还有匿名行盒、匿名块盒等等都会导致DOM树和布局树无法一一对应



## 分层

渲染主线程会使用一套复杂的策略对整个布局树中进行分层
分层的好处在于将来某一个层改变后，仅会对该层进行后续处理，从而提升效率
滚动条、堆叠上下文、transform、opacity等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果

![image-20250507184040290](./assets/image-20250507184040290.png)



## 绘制指令

渲染主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来

![image-20250507184733807](./assets/image-20250507184733807.png)

完成绘制后，渲染主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成

![image-20250507184802283](./assets/image-20250507184802283.png)



## 分块

合成线程首先对每个图层进行分块，将其划分为更多的小区域，它会从线程池中拿取多个线程来完成分块工作
分块的工作是交给多个线程同时进行的

![image-20250507185251047](./assets/image-20250507185251047.png)



## 光栅化

分块完成后，进入光栅化阶段
合成线程会将块信息交给GPU进程,，以极高的速度完成光栅化
GPU进程会开启多个线程来完成光栅化，**并且优先处理靠近视口区域的块**
光栅化的结果，就是一块一块的位图

![image-20250507185553325](./assets/image-20250507185553325.png)

![image-20250507185651429](./assets/image-20250507185651429.png)



## 画

最后一个阶段就是画了
合成线程拿到每个层、每个块的位图后，生成一个个【指引(quad)】信息
指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形
变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因
合成线程会把quad提交给GPU进程，由GPU进程产生系统调用，提交给GPU硬件，完成最终的屏幕成像



## `Reflow`?

回流，页面重排布局
Reflow的本质就是重新计算layout树
当进行了会影响布局树的操作后，需要重新计算布局树，会引发layout布局重新计算
为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作：
**reflow非常耗时，浏览器为了提升性能，对JS中连续导致reflow的代码，把reflow的时间点延迟到结束后进行**
**但在此过程中，如果遇到了获取尺寸和位置的代码，浏览器会迫不得已立即 reflow**
**所以改动属性造成的Reflow是异步完成的**
也同样因为如此，当JS获取布局属性时，就可能造成无法获取到最新的布局信息

```js
/** 进行哪些操作会导致 reflow 重排 **/
// 1. 获取元素的尺寸和位置
// 2. 直接或间接改变元素的尺寸和位置

// 浏览器在反复权衡下，最终决定获取属性立即Reflow
```

![image-20250507191734289](./assets/image-20250507191734289.png)



## `Repaint`?

重绘，Repaint的本质就是重新根据分层信息重计算了绘制指令
当改动了可见样式后，就需要重新计算，会引发Repaint
**由于元素的布局信息也属于可见样式，所以Reflow一定会引起Repaint**
绘制Repaint的过程是靠GPU完成的，速度非常快
因此，**相对于导致Reflow的代码，仅会导致Repaint的代码效率会高出很多**

![image-20250507191702646](./assets/image-20250507191702646.png)



# 计算机储存

**计算机必须使用固定的位数来存储数字，无论存储的数字是大是小，在内存中占用的空间是固定的**
n位的无符号整数能表示的数字是2^n个，取值范围是：`0 ~ 2^n - 1`
n位的有符号整数能表示的数字是2^n个，取值范围是：`-2^(n - 1) ~ 2^(n - 1) - 1 `

浮点数表示法可以用于表示整数和小数，目前分为两种标准：

- 32位浮点数：又称为单精度浮点数，它用1位表示符号，8位表示阶码，23位表示尾数
- 64位浮点数：又称为双精度浮点数，它用1位表示符号，11位表示阶码，52位表示尾数

有符号储存第一位为`1`表示负数，`0`表示正数

**JS中的所有数字，均使用双精度浮点数保存**，使用`IEEE 754`标准
例如，在js中储存100个0，需要占用`64 * 100 = 6400 bit`，而`8bit = 1byte; 1024byte = 1kb; 1024kb = 1mb`



# 类型化数组

用于优化储存大量数字，避免内存空间的浪费
**类型化数组不能增加和删除数据（操作无效），因为长度固定、占用内存空间固定**
其他用法和普通数组一致，也可以使用`.map`等方法

类型化数组中只能存储该类型取值范围内的数字
例如`Int8Array`的储存范围在`-128 ~ 127`，如果某个元素超过了127，则会导致实际储存数字不同

```js
/**
* Int8Array：8位有符号整数（-128 ~ 127）
* Uint8Array：8位无符号整数（0 ~ 255）
* Int16Array：16位有符号整数
* Uint16Array：16位无符号整数
* Int32Array：32位有符号整数
* Uint32Array：32位无符号整数
**/

// 创建有10个元素值默认都为0的类型化数组
const arr = new Int16Array(10) // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
arr.length // 10，元素个数
arr.byteLength // 20，占用字节长度：10 * 16 / 8 = 20 byte

// 使用`.of`静态方法构建初始化元素
const initarr = Int8Array.of(3, 5, 6, 2, 0) // Int8Array(5) [3, 5, 6, 2, 0]

// 从一个普通数组得到一个类型化数组
const arr = new Uint16Array([0, 14, 435, 232, 32])
arr[2] = 64 // 修改下标为2的元素的值
```



# `ArrayBuffer`

**一个对象，用于储存一个固定大小的数据，用来表示通用的原始二进制数据缓冲区**，[MDN参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)
语法：`new ArrayBuffer(字节数)`
可以通过`byteLength`读取字节数，通过`slice`切割得到一个新的`ArrayBuffer`
**不能直接操作`ArrayBuffer` 中的内容，而是要通过类型化数组或`DataView`来操作**

```js
// 创建一个固定储存 10 个字节大小的数组，值都默认为 0
const arr = new ArrayBuffer(10)

// 使用 DateView 来操作数组
const dv = new DataView(arr, 0, 10) // 语法：new DataView(arraybuffer, offset, byteLength)

// 使用类型化数组
// 实际上，每一个类型化数组都对应一个ArrayBuffer，如果创建类型化数组时没有指定ArrayBuffer，则会新建一个
const bf = new ArrayBuffer(10)
const arr1 = new Int8Array(bf)
const arr2 = new Int16Array(bf)
arr1 === arr2 // false
arr1.buffer === arr2.buffer // true
arr1[0] = 10 // 因为两个类型化数组共用一个内存空间，所以更改arr1的数据后，arr2也会一起更新
```







